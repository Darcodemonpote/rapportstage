import React from 'react';
import CodeBlock from '@theme/CodeBlock';
import styles from './resynchro.module.css';

### Contexte

Dans le cadre de la mise en place de la norme RGPD, il y a eu la mise en place d'une purge sur la base de donn√©e contenant les contrats/devis ajout√©s par les utilisateurs (DB2), or la base de donn√©e du datahub n'a pas subis ces memes mises √† jours, et donc les donn√©es n'avaient pas √©t√© purg√©s de ce cot√©.
Le composant li√© aux contrats et devis automobile (**prodauto**) fait partie des composants aff√©ct√©s par cela.

Pour assurer la bonne **conformit√©** avec les exigences RGPD, il faut donc **resynchroniser** ces donn√©es supprim√©es en les r√©int√©grant dans le processus de purge, afin qu‚Äôelles soient correctement prises en compte.

---

### Objectif

* R√©cuperer et ing√©rer /A EXPLIQUER\ un Unload de la base DB2 qui correspont aux donn√©es n'ayant pas √©t√© purg√©s.
* G√©n√©rer un fichier **delta** qui identifie les donn√©es absentes ou non trait√©es dans la base actuelle, pour une purge compl√®te et fiable.

---

### Contraintes techniques

* R√©utilisation d'identifiants pour les 3 tables de prodauto (table des contrats, contrats √† effet diff√©r√© et devis)/
  Tant que la resynchronisation avec le Datahub n‚Äôa pas eu lieu, le Datahub conserve encore l‚Äôancien contrat non purg√©, ce qui fait qu'on peut avoir m√™me identifiant pour plusieurs contrats diff√©rents (ancien et nouveau).
* La manipulation repose sur des **requ√™tes SQL** avec des jointures et des fonctions analytiques.

---

##  Job `contrat_tpacon10` *(dont les '$' ont √©t√©s supprim√©s pour raisons techniques)*

<div className={styles.sideBySide}>
  <div className={styles.left}>
    <CodeBlock language="yaml">
{`
zone: "ing"
origine: "maaf"
cal: "prodauto"
name: "contrat_tpacon10"
vars:
  table-name-source: "tpacon10"
  directory: "/{env}/ing/maaf/prodauto/rgpd/data_guide_contrat"
  table-cible: "data_guide_contrat_incoming"
  flux: "resynchro"
  date_arch: "31/12/2024"
  delay_reuse: "36"

stages:
  - stage: "suppression data_guide"
    type: "CLEAN_DIR_HDFS"
    condition: "modePattern==\"prepare\""
    params:
      directories:
        - "{directory}"
        - "{directory}/staging"
        - "{directory}/stagingArchives"
        - "{directory}/incoming"
        - "{directory}/reconcile"
        - "{directory}/base"
        - "{directory}/histo"
  - stage: "multi_data_prep"
    type: "MULTI_DATA_PREP"
    condition: "modePattern==\"prepare\""
    params:
      sources:
        - name: "resynchro_tpacon10"
          type: table
          table-name: "{flux}_{table-name-source}"
          schema-file: "schema/metcdc/tpacon10.yaml"
          directory: "/{env}/ing/maaf/prodauto/{flux}/tpacon10"
        - name: "metcdc_tpacon10_base"
          type: table
          table-name: "metcdc_{table-name-source}_base"
          schema-file: "schema/metcdc/tpacon10.yaml"
          directory: "/{env}/ing/maaf/prodauto/metcdc/tpacon10/base"
        - name: "metcdc_tpacon10_histo"
          type: table
          table-name: "metcdc_{table-name-source}_histo"
          schema-file: "schema/metcdc/tpacon10.yaml"
          directory: "/{env}/ing/maaf/prodauto/metcdc/tpacon10/histo"
      transformations:
        - name: "data_guide_contrat_incoming"
          type: parquet
          base: "/{env}/ing/maaf/prodauto/rgpd/data_guide_contrat/incoming"
          directory: "/{env}/ing/maaf/prodauto/rgpd/data_guide_contrat/incoming"
          schema-file: "schema/RGPD/data_guide_contrat_rgpd_incoming.yaml"
          table-name: "{table-cible}"
          query: "
                  SELECT 'contrat'                                                                                 AS ctymet,
                         t3.nsc                                                                                    AS nsc,
                         t3.ncnt                                                                                   AS ncnt,
                                Concat( '31/12/', Cast(Cast(Substr(t3.base_timestamp,1,4) AS INT) - 1 AS STRING) ) AS dpasarch,
                         ''                                                                                        AS dapurge,
                         date_format(CURRENT_TIMESTAMP,'yyyy-MM-dd HH:mm:ss')                                      AS date_ingestion
                  FROM   (
                                  SELECT   t2.nsc,
                                           t2.ncnt,
                                           t2.min_dnrdef,
                                           t2.max_dnrdef,
                                           t2.base_timestamp,
                                           Row_number()
                                             OVER (
                                               partition BY t2.nsc, t2.ncnt
                                               ORDER BY t2.base_timestamp ASC
                                               ) AS rn
                                  FROM     (
                                                  SELECT     j.nsc,
                                                              j.ncnt,
                                                              Min(j.dnrdef) OVER (partition BY j.nsc, j.ncnt)             AS min_dnrdef,
                                                              Max(j.dnrdef) OVER (partition BY j.nsc, j.ncnt)             AS max_dnrdef,
                                                              MAX(n.dtl__capxtimestamp) OVER (partition BY j.nsc, j.ncnt) AS base_timestamp
                                                  FROM       metcdc_tpacon10_histo j
                                                  INNER JOIN resynchro_tpacon10 n
                                                  ON         j.nsc = n.nsc
                                                  AND        j.ncnt = n.ncnt ) AS t2
                                  WHERE    add_months(t2.min_dnrdef, {delay_reuse}) < t2.max_dnrdef ) AS t3
                  WHERE  t3.rn = 1
                  UNION ALL
                  SELECT 'contrat'                                             AS ctymet,
                         b.nsc                                                 AS nsc,
                         b.ncnt                                                AS ncnt,
                         cast('{date_arch}' AS string)                        AS dpasarch,
                         ''                                                    AS dapurge,
                         date_format(CURRENT_TIMESTAMP,'yyyy-MM-dd HH:mm:ss')  AS date_ingestion
                  FROM   metcdc_tpacon10_base b
                  WHERE  NOT EXISTS
                         (
                                SELECT 1
                                FROM   resynchro_tpacon10 i
                                WHERE  b.nsc = i.nsc
                                AND    b.ncnt = i.ncnt
                         )"
`}
    </CodeBlock>
  </div>
  <div className={styles.right}>
  <h2>Explication du job <code>contrat_tpacon10</code></h2>

  <p>
    Le job <code>contrat_tpacon10</code> a √©t√© mis en place pour assurer la
    <strong> resynchronisation des donn√©es de contrats automobiles </strong>
    li√©es au composant prodauto dans le cadre de la mise en conformit√© RGPD.
    Il vise √† r√©int√©grer dans le processus de purge les contrats qui avaient √©t√© supprim√©s
    de la base <strong>DB2</strong>, mais qui sont toujours pr√©sents dans le <strong>Datahub</strong>.
  </p>

  <h3>Fonctionnement g√©n√©ral</h3>
  <p>
    Ce job se base sur une <strong>analyse crois√©e</strong> entre l‚Äôunload issu de DB2 (<code>resynchro_tpacon10</code>)
    et les historiques/base existants du Datahub (<code>metcdc_tpacon10_histo</code> et <code>metcdc_tpacon10_base</code>).
    Il est structur√© en plusieurs √©tapes.
  </p>

  <h3>√âtape 1 ‚Äì Nettoyage des r√©pertoires HDFS</h3>
  <p>
    Avant tout traitement, les r√©pertoires de travail li√©s √† la table <code>data_guide_contrat</code> sont nettoy√©s :
  </p>
  <ul>
    <li>R√©pertoires <code>staging</code>, <code>incoming</code>, <code>reconcile</code>, <code>base</code>, <code>histo</code>, etc...</li>
    <li>√âvite les doublons ou conflits issus d‚Äôun traitement pr√©c√©dent.</li>
  </ul>

  <h3>√âtape 2 ‚Äì Pr√©paration des donn√©es (stage <code>multi_data_prep</code>)</h3>
  <p>Cette √©tape charge les diff√©rentes sources n√©cessaires √† la resynchronisation :</p>

  <h4>Sources utilis√©es</h4>
  <ul>
    <li><code>resynchro_tpacon10</code> : dump de DB2 contenant les contrats cens√©s avoir √©t√© purg√©s</li>
    <li><code>metcdc_tpacon10_base</code> : √©tat actuel des contrats dans le Datahub (base)</li>
    <li><code>metcdc_tpacon10_histo</code> : historique des modifications sur ces contrats dans le Datahub</li>
  </ul>

  <p><strong>Objectif :</strong> Comparer ces sources pour identifier deux cas distincts.</p>

  <h3>Transformation logique ‚Äì G√©n√©ration du fichier <code>data_guide_contrat_incoming</code></h3>
  <p>
    La logique de transformation SQL permet de g√©n√©rer le fichier <code>data_guide_contrat_incoming</code>,
    qui contient les contrats √† int√©grer dans le processus de purge.
  </p>

  <h4>Deux types de cas sont extraits :</h4>
  <ol>
    <li>
      <strong>Cas 1 ‚Äì Contrats r√©utilis√©s</strong> (m√™me identifiant, contrat diff√©rent)<br />
      Identifi√©s par une diff√©rence entre les dates de r√©f√©rence (<code>dnrdef</code>) min/max
      et un d√©calage sup√©rieur au d√©lai (<code>delay_reuse</code>).<br />
      On s√©lectionne le premier enregistrement chronologique (<code>ROW_NUMBER() = 1</code>) pour chaque identifiant.
    </li>
    <li>
      <strong>Cas 2 ‚Äì Contrats inexistants dans DB2</strong> (non purg√©s)<br />
      Contrats encore pr√©sents dans le Datahub, mais absents du dump.<br />
      G√©n√©r√©s via un <code>NOT EXISTS</code> entre la base <code>metcdc</code> et le dump <code>resynchro</code>.
    </li>
  </ol>

  <p>Chaque ligne du fichier delta est enrichie avec les champs suivants :</p>
  <ul>
    <li><code>dpasarch</code> : date cible de purge (souvent 31/12/ann√©e pr√©c√©dente)</li>
    <li><code>dapurge</code> : champ vide, compl√©t√© lors de la purge r√©elle</li>
    <li><code>date_ingestion</code> : horodatage du job</li>
  </ul>

  <h3>R√©sultat attendu</h3>
  <ul>
    <li>Les contrats absents ou mal purg√©s sont correctement identifi√©s</li>
    <li>Un fichier Parquet est g√©n√©r√© dans le r√©pertoire <code>incoming</code>, pr√™t √† √™tre int√©gr√© dans la cha√Æne de purge RGPD</li>
  </ul>

  <h3>Liens avec les contraintes RGPD</h3>
  <p>
    Ce job assure une tra√ßabilit√© compl√®te des contrats √† purger et garantit que les √©ventuelles
    r√©utilisations d'identifiants n'interf√®rent pas avec les exigences RGPD.
  </p>
  <ul>
    <li>Les donn√©es personnelles sont supprim√©es dans tous les syst√®mes concern√©s</li>
    <li>Les fichiers de purge sont conformes et justifiables en cas d‚Äôaudit RGPD</li>
  </ul>
</div>
</div>

---

### üó∫Ô∏è Sch√©ma de purge

![schema](/img/schema.png)
